/* eslint-disable */
module.exports = {
name: "@yarnpkg/plugin-prebuilds",
factory: function (require) {
var plugin;plugin=(()=>{var e={224:(e,t,r)=>{"use strict";r.r(t),r.d(t,{default:()=>h});const i=require("@yarnpkg/core"),n=require("@yarnpkg/fslib"),a=require("@yarnpkg/libzip");var s=r(308);const o=require("@yarnpkg/plugin-npm");function l(e,t,r){const i=r.configuration,n="@"+e.scope,a=(e.scope?function(e,t){const r=t.get("prebuildScopes").get(e);return void 0!==r?r:null}(n,i):null)||i;return a.get(t)?a.get(t):i.get(t)}function c(e){return(0,s.Vn)(e,"electron")}function u(){switch(process.arch){case"arm":return"armv7l";default:return process.arch}}async function p(e,t,r){const n=i.structUtils.stringifyIdent(e).replace(/^@\w+\//,""),a=e.version,s=r.abi,c=r.runtime,p=process.platform,f=u(),d=process.env.LIBC||"",g=l(e,"prebuildTagPrefix",t),m=`${n}-v${a}-${c}-v${s}-${p}${d}-${f}.tar.gz`,b=l(e,"prebuildHostMirrorUrl",t);if(b){return function(e,t){for(const[r,i]of Object.entries(t))e=e.replace(new RegExp(`{${r}}`,"g"),i);return e}(l(e,"prebuildHostMirrorTemplate",t),{mirror_url:b,name:n,version:a,abi:s,runtime:c,platform:p,arch:f,libc:d,tag_prefix:g,scope:e.scope||"",scopeWithAt:e.scope?"@"+e.scope:"",scopeWithAtAndSlash:e.scope?`@${e.scope}/`:"",scopeWithSlash:e.scope?e.scope+"/":""})}return`${await async function(e,t){var r;const n=await o.npmHttpUtils.get(o.npmHttpUtils.getIdentUrl(e),{configuration:t.configuration,ident:e,json:!0});if(!Object.prototype.hasOwnProperty.call(n,"versions"))throw new i.ReportError(i.MessageName.REMOTE_INVALID,'Registry returned invalid data for - missing "versions" field');if(!Object.prototype.hasOwnProperty.call(n.versions,e.version))throw new i.ReportError(i.MessageName.REMOTE_NOT_FOUND,`Registry failed to return reference "${e.version}"`);const a=null===(r=n.versions[e.version].repository)||void 0===r?void 0:r.url;if(!a)throw new i.ReportError(i.MessageName.UNNAMED,`Unable to find repository information for "${i.structUtils.stringifyIdent(e)}"`);const s=function(e){var t=/github\.com\/([^\/]+)\/([^\/\.]+)\.git/.exec(e);return t?`https://github.com/${t[1]}/${t[2]}`:null}(a);if(!s)throw new i.ReportError(i.MessageName.UNNAMED,`Unable to find GitHub URL for "${i.structUtils.stringifyIdent(e)}"`);return s}(e,t)}/releases/download/${g}${a}/${m}`}const f=async(e,t,r,i)=>{if(i.cancel)return;const a=await e.readdirPromise(t);await Promise.all(a.map(async a=>{if(i.cancel)return;const s=n.ppath.join(t,a),o=await e.statPromise(s);o.isDirectory()?await f(e,s,r,i):o.isFile()&&await r(e,s)}))},d=require("stream");async function g(e,t,r,s,o){const{packageLocation:l,packageFs:g}=await async function(e,t){const r=t.storedPackages.get(e.locatorHash);if(!r)throw new Error(`Package for ${i.structUtils.prettyLocator(t.configuration,e)} not found in the project`);return await n.ZipOpenFS.openPromise(async e=>{const a=t.configuration,s=t.configuration.getLinkers(),o={project:t,report:new i.StreamReport({stdout:new d.PassThrough,configuration:a})},l=s.find(e=>e.supportsPackage(r,o));if(!l)throw new Error(`The package ${i.structUtils.prettyLocator(t.configuration,r)} isn't supported by any of the available linkers`);const c=await l.findPackageLocation(r,o);return{packageLocation:c,packageFs:new n.CwdFS(c,{baseFs:e})}},{libzip:await(0,a.getLibzipPromise)()})}(t,r),m={abi:o?c(o):process.versions.modules,runtime:o?"electron":"node"};"fsevents"===e.name&&null===e.scope&&(m.abi=process.versions.modules,m.runtime="node");const b=`${i.structUtils.stringifyIdent(e)}-${e.version}-${process.platform}-${u()}-${m.runtime}-${m.abi}`.replace(/\//g,"-"),h=n.ppath.join(l,".cache_key");if(await g.existsPromise(h)){if((await g.readFilePromise(h)).toString()===b)return void s.report.reportInfo(i.MessageName.UNNAMED,i.structUtils.stringifyLocator(e)+" cache keys match, skipping installation")}const w=await p(e,r,m),y=r.configuration.makeFetcher();let v;try{v=await y.fetch(i.structUtils.makeLocator(i.structUtils.makeIdent("prebuilds",b),w),{cache:s.cache,checksums:r.storedChecksums,report:s.report,project:r,fetcher:y})}catch(e){throw s.report.reportInfo(i.MessageName.UNNAMED,"Error fetching "+w),e}const k={cancel:!1};let P=null,U="";if(await i.miscUtils.releaseAfterUseAsync(async()=>{await f(v.packageFs,".",async(e,t)=>{P=await e.readFilePromise(t),U=t,k.cancel=!0},k)},v.releaseFs),null===P)throw new i.ReportError(i.MessageName.UNNAMED,`Was unable to find node file in prebuild package for "${i.structUtils.stringifyIdent(e)}"`);await g.writeJsonPromise(n.ppath.join(l,"package.json"),{name:i.structUtils.slugifyLocator(t),main:"./index.js"});const N=`// Automatically generated bindings file for ${i.structUtils.stringifyIdent(e)}\n// Package version: ${e.version}\n// Runtime: ${m.runtime}, ABI: ${m.abi}\n// Bindings taken from: ${U}\n\nconst staticRequire = require("./bindings.node");\nmodule.exports = (fileLookingFor) => {\n  return staticRequire;\n};\n`;await g.writeFilePromise(n.ppath.join(l,"index.js"),N),await g.writeFilePromise(n.ppath.join(l,"bindings.node"),P),await g.writeFilePromise(h,b),s.report.reportInfo(i.MessageName.UNNAMED,"Installed prebuild for "+i.structUtils.stringifyLocator(e))}function m(e){return("fsevents"!==e.name||"darwin"===process.platform)&&("bindings"===e.name&&null===e.scope)}const b={prebuildRuntime:{description:"The runtime used, either 'electron' or 'node'",type:i.SettingsType.STRING,default:null},prebuildAbi:{description:"The ABI of the runtime used.",type:i.SettingsType.STRING,default:null},prebuildTagPrefix:{description:"The prebuild tag prefix",type:i.SettingsType.STRING,default:"v"},prebuildHostMirrorUrl:{description:"The prebuild host mirror URL",type:i.SettingsType.STRING,default:null},prebuildHostMirrorTemplate:{description:"The prebuild host mirror template",type:i.SettingsType.STRING,default:"{mirror_url}/{tag_prefix}{version}/{name}-v{version}-{runtime}-v{abi}-{platform}{libc}-{arch}.tar.gz"}},h={hooks:{reduceDependency:async(e,t,r,n,a)=>{if("fsevents"===r.name&&"darwin"!==process.platform)return e;if("bindings"===e.name&&null===e.scope){return i.structUtils.makeDescriptor(e,i.structUtils.makeRange({protocol:"prebuild:",source:i.structUtils.stringifyDescriptor(e),selector:`bindings<${i.structUtils.stringifyLocator(r)}>`,params:null}))}return e},afterAllInstalled:async function(e,t){await t.report.startTimerPromise("Native dependency resolution",async()=>{await async function(e,t){const r=new Map,n=await(async e=>{for(const t of e.storedPackages.values())if("electron"===t.name)return t.version;return null})(e);n&&t.report.reportInfo(i.MessageName.UNNAMED,"Using Electron runtime v"+n);for(const t of e.storedPackages.values())m(t)&&r.set(t.locatorHash,t);for(const a of e.storedPackages.values())for(const[s,o]of a.dependencies){const s=r.get(o.descriptorHash);if(s){try{await g(a,s,e,t,n)}catch(e){t.report.reportInfo(i.MessageName.UNNAMED,"Couldn't mutate bindings for "+i.structUtils.stringifyLocator(a)),console.error(e)}break}}}(e,t)})}},fetchers:[class{supports(e,t){return!!e.reference.startsWith("prebuild:")}getLocalPath(e,t){return null}async fetch(e,t){const r=new n.NodeFS,{zipPackage:s}=await this.fetchPrebuild(e,t),o=s.getRealPath();await n.xfs.chmodPromise(o,420);const l=`${t.cache.cacheKey}/${e.locatorHash}`,c=t.cache.getLocatorPath(e,l);if(t.cache.markedFiles.add(c),!c)throw new Error("Assertion failed: Expected the cache path to be available");await n.xfs.mkdirpPromise(n.ppath.dirname(c)),await n.xfs.movePromise(o,c);let u=null;const p=await(0,a.getLibzipPromise)();return{packageFs:new n.LazyFS(()=>i.miscUtils.prettifySyncErrors(()=>u=new n.ZipFS(c,{baseFs:r,libzip:p,readOnly:!0}),r=>`Failed to open the cache entry for ${i.structUtils.prettyLocator(t.project.configuration,e)}: ${r}`),n.ppath),releaseFs:()=>{null!==u&&u.discardAndClose()},prefixPath:i.structUtils.getIdentVendorPath(e),localPath:this.getLocalPath(e,t),checksum:l}}async fetchPrebuild(e,t){const r=await n.xfs.mktempPromise(),s=n.ppath.join(r,"prebuilt.zip"),o=i.structUtils.getIdentVendorPath(e),l=new n.ZipFS(s,{libzip:await(0,a.getLibzipPromise)(),create:!0});await l.mkdirpPromise(o);const c=new n.CwdFS(o,{baseFs:l});await c.writeJsonPromise("package.json",{name:i.structUtils.slugifyLocator(e),main:"./index.js",preferUnplugged:!0});const u=`// This will be replaced at the end of the build step\n    // locatorHash: ${e.locatorHash}\n    `;return await c.writeFilePromise("index.js",u),l.saveAndClose(),{zipPackage:l}}}],resolvers:[class{supportsDescriptor(e,t){return!!e.range.startsWith("prebuild:")}supportsLocator(e,t){return!!e.reference.startsWith("prebuild:")}shouldPersistResolution(e,t){return!1}bindDescriptor(e,t,r){return e}getResolutionDependencies(e,t){return[]}async getCandidates(e,t,r){if(!r.fetchOptions)throw new Error("Assertion failed: This resolver cannot be used unless a fetcher is configured");return[i.structUtils.makeLocator(i.structUtils.parseIdent("bindings"),e.range)]}async getSatisfying(e,t,r){return null}async resolve(e,t){return{...e,version:"*",languageName:t.project.configuration.get("defaultLanguageName"),linkType:i.LinkType.HARD,dependencies:new Map,peerDependencies:new Map,dependenciesMeta:new Map,peerDependenciesMeta:new Map,bin:new Map}}}],configuration:{...b,prebuildScopes:{description:"Prebuild settings per package scope",type:i.SettingsType.MAP,valueDefinition:{description:"",type:i.SettingsType.SHAPE,properties:{...b}}}}}},908:e=>{"use strict";e.exports=JSON.parse('[{"runtime":"node","target":"11.0.0","lts":false,"future":false,"abi":"67"},{"runtime":"node","target":"12.0.0","lts":["2019-10-21","2020-11-30"],"future":false,"abi":"72"},{"runtime":"node","target":"13.0.0","lts":false,"future":false,"abi":"79"},{"runtime":"node","target":"14.0.0","lts":["2020-10-27","2021-10-19"],"future":false,"abi":"83"},{"runtime":"node","target":"15.0.0","lts":false,"future":false,"abi":"88"},{"runtime":"node","target":"16.0.0","lts":["2021-10-26","2022-10-18"],"future":false,"abi":"93"},{"abi":"70","future":false,"lts":false,"runtime":"electron","target":"5.0.0-beta.9"},{"abi":"73","future":false,"lts":false,"runtime":"electron","target":"6.0.0-beta.1"},{"abi":"75","future":false,"lts":false,"runtime":"electron","target":"7.0.0-beta.1"},{"abi":"76","future":false,"lts":false,"runtime":"electron","target":"8.0.0-beta.1"},{"abi":"80","future":false,"lts":false,"runtime":"electron","target":"9.0.0-beta.2"},{"abi":"82","future":false,"lts":false,"runtime":"electron","target":"10.0.0-beta.1"},{"abi":"85","future":false,"lts":false,"runtime":"electron","target":"11.0.0-beta.11"},{"abi":"87","future":false,"lts":false,"runtime":"electron","target":"12.0.0-beta.1"},{"abi":"89","future":false,"lts":false,"runtime":"electron","target":"13.0.0-beta.2"}]')},308:(e,t,r)=>{var i=r(513);function n(e,t){null==t&&(t=d);var r=t.filter((function(t){return t.runtime===e})).slice(-1)[0],n="electron"===e?"minor":"major",a=i.inc(r.target,n);return"electron"===e&&i.parse(r.target).prerelease.length&&(a=i.inc(a,"major")),a}function a(e,t){var r=Number(e.abi)-Number(t.abi);return 0!==r?r:e.target<t.target?-1:e.target>t.target?1:0}var s,o,l=(s=r(908),o={supported:[],additional:[],future:[]},s.forEach((function(e){var t={runtime:e.runtime,target:e.target,abi:e.abi};if(e.lts){var r=new Date(Date.parse(e.lts[0])),i=new Date(Date.parse(e.lts[1])),n=new Date;t.lts=r<n&&n<i}else t.lts=!1;"node-webkit"===t.runtime?o.additional.push(t):e.future?o.future.push(t):o.supported.push(t)})),o.supported.sort(a),o.additional.sort(a),o.future.sort(a),o),c=[{runtime:"node",target:"5.0.0",abi:"47",lts:!1},{runtime:"node",target:"6.0.0",abi:"48",lts:!1},{runtime:"node",target:"7.0.0",abi:"51",lts:!1},{runtime:"node",target:"8.0.0",abi:"57",lts:!1},{runtime:"node",target:"9.0.0",abi:"59",lts:!1},{runtime:"node",target:"10.0.0",abi:"64",lts:new Date(2018,10,1)<new Date&&new Date<new Date(2020,4,31)},{runtime:"electron",target:"0.36.0",abi:"47",lts:!1},{runtime:"electron",target:"1.1.0",abi:"48",lts:!1},{runtime:"electron",target:"1.3.0",abi:"49",lts:!1},{runtime:"electron",target:"1.4.0",abi:"50",lts:!1},{runtime:"electron",target:"1.5.0",abi:"51",lts:!1},{runtime:"electron",target:"1.6.0",abi:"53",lts:!1},{runtime:"electron",target:"1.7.0",abi:"54",lts:!1},{runtime:"electron",target:"1.8.0",abi:"57",lts:!1},{runtime:"electron",target:"2.0.0",abi:"57",lts:!1},{runtime:"electron",target:"3.0.0",abi:"64",lts:!1},{runtime:"electron",target:"4.0.0",abi:"64",lts:!1},{runtime:"electron",target:"4.0.4",abi:"69",lts:!1}];c.push.apply(c,l.supported);var u=[{runtime:"node-webkit",target:"0.13.0",abi:"47",lts:!1},{runtime:"node-webkit",target:"0.15.0",abi:"48",lts:!1},{runtime:"node-webkit",target:"0.18.3",abi:"51",lts:!1},{runtime:"node-webkit",target:"0.23.0",abi:"57",lts:!1},{runtime:"node-webkit",target:"0.26.5",abi:"59",lts:!1}];u.push.apply(u,l.additional);var p=[{runtime:"node",target:"0.2.0",abi:"1",lts:!1},{runtime:"node",target:"0.9.1",abi:"0x000A",lts:!1},{runtime:"node",target:"0.9.9",abi:"0x000B",lts:!1},{runtime:"node",target:"0.10.4",abi:"11",lts:!1},{runtime:"node",target:"0.11.0",abi:"0x000C",lts:!1},{runtime:"node",target:"0.11.8",abi:"13",lts:!1},{runtime:"node",target:"0.11.11",abi:"14",lts:!1},{runtime:"node",target:"1.0.0",abi:"42",lts:!1},{runtime:"node",target:"1.1.0",abi:"43",lts:!1},{runtime:"node",target:"2.0.0",abi:"44",lts:!1},{runtime:"node",target:"3.0.0",abi:"45",lts:!1},{runtime:"node",target:"4.0.0",abi:"46",lts:!1},{runtime:"electron",target:"0.30.0",abi:"44",lts:!1},{runtime:"electron",target:"0.31.0",abi:"45",lts:!1},{runtime:"electron",target:"0.33.0",abi:"46",lts:!1}],f=l.future,d=p.concat(c).concat(u).concat(f);t.Vn=function(e,t){if(e===String(Number(e)))return e;if(e&&(e=e.replace(/^v/,"")),t||(t="node"),"node"===t){if(!e)return process.versions.modules;if(e===process.versions.node)return process.versions.modules}for(var r,a=0;a<d.length;a++){var s=d[a];if(s.runtime===t){if(!i.lte(s.target,e))break;r=s.abi}}if(r&&i.lt(e,n(t)))return r;throw new Error("Could not detect abi for version "+e+" and runtime "+t+'.  Updating "node-abi" might help solve this issue if it is a new release of '+t)}},513:e=>{"use strict";e.exports=require("semver")}},t={};function r(i){if(t[i])return t[i].exports;var n=t[i]={exports:{}};return e[i](n,n.exports,r),n.exports}return r.d=(e,t)=>{for(var i in t)r.o(t,i)&&!r.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:t[i]})},r.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r(224)})();
return plugin;
}
};